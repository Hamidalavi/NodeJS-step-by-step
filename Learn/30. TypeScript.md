# TypeScript with Node

In this file, you will learn about: **TypeScript**

**TypeScript** is a language which is extends from **JavaScript**. **TypeScript** does not run in the browser. Instead, **TypeScript** has to compiled to **JavaScript**.

Why we need to learn and use it? Because **TypeScript** have more features and give us a better experience. We can avoid some unwanted error with **TypeScript**:

```js
// app.js
function add(num1, num2) {
  return num1 + num2;
}

console.log(add(15, 8)); // 23
```

This a simple `add` function here that returns `num1 + num2`. Now if we want to add two numbers with string, we would see the different output:

```js
// app.js
function add(num1, num2) {
  return num1 + num2;
}

console.log(add("15", "8")); // "158"
```

Because we concat two string here. As you know, if you have an operation with a `+` and at least one of the two operands is a string, then both will be combined as strings.

This is a problem here, we don't want to concat them as string. Now that's where **TypeScript** can help us.

**TypeScript** have nice features like **Types**, **Next-gen JavaScript features (compiled down for older browsers)** and **Non-JavaScript features like `interface` or Genetics** (we work them in some programming languages like C++ or C#).

Some other features also **TypeScript** have and they are **meta-programming features like decorators**, **rich configuration options** and **modern tooling that helps even in non-TypeScript projects**.

## Starting TypeScript

Consider this example:

```js
// app.js
function add(num1, num2) {
  return num1 + num2;
}
```

This functon works good, but if we want to add two numbers as string we have minor problem here:

```js
// app.js
function add(num1, num2) {
  return num1 + num2;
}

console.log(add("15", "8")); // "158"
```

We got `158` instead of `23`. This is a anwanted value we get.

We can avoid these errors with the help of **TypeScript**. To work with **TypeScript**, first of all we need to install this compiler on our machine.

We can install it with `npm install -g typescript` command.

**Note**: For MAC and Linux you need to add `sudo` first of the command (i.e. `sudo npm install -g typescript`).

For the rest of our course, we work with `.ts` file extension which is for **TypeScript**. For example:

```ts
// app.ts
function add(num1, num2) {
  return num1 + num2;
}

console.log(add(15, 8)); // 23
console.log(add("15", "8")); // "158"
```

We still have this issue, we can solve that issue with type definitions (i.e. assigning types).

## Type Definitions

We want avoid that strings can pass in. For that, in **TypeScript** files we can set types; we can set types on variables, parameters and in a bunch of other places.

In this example, we want to set types on parameters. To setting types on parameters, we can add `:` colon next to the parameter name and the **type**, for example:

```ts
// app.ts
function add(num1: number, num2: number) {
  return num1 + num2;
}
```

We can set `number`, `string`, `boolean`, `object` and `Array` and other types to our parameters, variables and so on. Now if we want to test below example:

```ts
// app.ts
console.log(add("15", "8")); // "158"
//               ~~
```

our editor (VS Code) will complain about that and it says us **you must add numbers in `add` function's parameters. Other types will be rejected**; or it says: `Argument of type 'string' is not assignable to parameter of type 'number'.ts(2345)`. So we need to do like:

```ts
// app.ts
function add(num1: number, num2: number) {
  return num1 + num2;
}

console.log(add(15, 8)); // 23
```

Now we need to compile it to **JavaScript** code with `tsc app.ts` command. As we said, **TypeScript** has to compiled to **JavaScript**.

## Type Inference & Type Casting

Consider this HTML content here:

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeScript</title>
    <script src="app.js" defer></script>
</head>

<body>
    <input type="text" id="num1">
    <input type="text" id="num2">
    <button>Add</button>
</body>

</html>
```

Now we want to get access HTML elements:

```ts
// app.ts
const num1Element = document.getElementById("num1");
const num2Element = document.getElementById("num2");
const button = document.querySelector("button");

function add(num1: number, num2: number) {
  return num1 + num2;
}

button.addEventListener("click", () => {});
```

In this example above, `button` implicitly inferred to `HTMLButtonElement` type. We didn't define this type explicitly. We can add it manually but we don't have to do this; because **TypeScript** is able to infer types and it's really smart regarding that.

Now inside the event listener, we want to extract the values from `num1` and `num2` elements:

```ts
// app.ts
const num1Element = document.getElementById("num1");
const num2Element = document.getElementById("num2");
const button = document.querySelector("button");

function add(num1: number, num2: number) {
  return num1 + num2;
}

button.addEventListener("click", () => {
    const num1 = num1Element.value;
    const num2 = num2Element.value;
});
```

If we use VS Code here (highly recommend to you to install it). We get an visual error in `value` property and **TypeScript** also don't like this way. The reason for that is, that not every HTML element has a `value` property. Input elements have `value` property, but Paragraphs for example, **don't**. We need to convince **TypeScript** that what we get access to here, **will be an input**.

In `const button = document.querySelector("button");` line, for the `button`, it knew that it's a button; because we query select by **button** tag. But in `const num1Element = document.getElementById("num1");` line, we select by `id`. So **TypeScript** has no chance of knowing which kind of element it will have those Ids.

But we can do something else related to types which is called **type casting**. We can use the special `as` keyword which is added by **TypeScript**, to tell **TypeScript** that what we select here will be of that type; for example, for input, we need to add input type to **TypeScript** know that contant as an input:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button");

function add(num1: number, num2: number) {
  return num1 + num2;
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
});
```

Now we don't have any problem here. We can use `add` function here inside of our event listener:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button");

function add(num1: number, num2: number) {
  return num1 + num2;
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(num1, num2);
});
```

OMG! We have a problem here, can you guess it? Yeah, as you know, all input in **JavaScript** are `string`. We need to convert them to number here:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button");

function add(num1: number, num2: number) {
  return num1 + num2;
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  console.log(result);
});
```

Now we compile this code to **JavaScript** code and we see:

```js
// app.js
var num1Element = document.getElementById("num1");
var num2Element = document.getElementById("num2");
var button = document.querySelector("button");
function add(num1, num2) {
  return num1 + num2;
}
button.addEventListener("click", function () {
  var num1 = num1Element.value;
  var num2 = num2Element.value;
  var result = add(+num1, +num2);
  console.log(result);
});
```

As you can see, we (and you) see the `as` operators gone and also all the types are gone.

**Note**: We can't use a type casting like this:

```ts
// app.ts
const num1Element: HTMLInputElement = document.getElementById("num1");
const num1Element: HTMLInputElement = document.getElementById("num2");
```

Instead we can use a different way:

```ts
// app.ts
const num1Input = <HTMLInputElement>document.getElementById("num1");
const num2Input = <HTMLInputElement>document.getElementById("num2");
```

## More on Type Inference

**TypeScript** has a built-in feature which is called **type inference**. Which means **TypeScript** is really doing its best and it's really smart, about inferring types we're working with. For example, we can write this code:

```ts
function add(a: number, b: number) {
  return a + b;
}

// hover over `add()` function => function add(a: number, b: number): number
const result = add(15, 8);

console.log(result);
```

It actually inferred the **return type** of the `add()` function. Since we store the **return value** of the `add()` function in `result`, **TypeScript** also infers that `result` holds the number. So **type inference** is a really a key feature of **TypeScript** as well; and it's a good practice to not unnecessarily reassign a type, **TypeScript** could infer anyways. For example, we don't have to assign the `number` in front of `result` constant:

```ts
// We don't have to add `number` in front of `result`
function add(a: number, b: number) {
  return a + b;
}

const result: number = add(15, 8);

console.log(result);
```

**Note**: As we said in previous section, `button` implicitly inferred to `HTMLButtonElement` type. We didn't define this type explicitly. We can add it manually but we don't have to do this; because **TypeScript** is able to infer types and it's really smart regarding that.

## Configuring TypeScript

Let's add some configuration to this project; we can add a configuration file which will be taken into account by the **TypeScript** compiler to this project by running `tsc --init`. This adds a `tsconfig.json` file which is contains:

```json
// tsconfig.json
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */
    /* Basic Options */
    // "incremental": true,                   /* Enable incremental compilation */
    "target": "es5", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */
    "module": "commonjs", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */
    // "lib": [],                             /* Specify library files to be included in the compilation. */
    // "allowJs": true,                       /* Allow javascript files to be compiled. */
    // "checkJs": true,                       /* Report errors in .js files. */
    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */
    // "declaration": true,                   /* Generates corresponding '.d.ts' file. */
    // "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */
    // "sourceMap": true,                     /* Generates corresponding '.map' file. */
    // "outFile": "./",                       /* Concatenate and emit output to single file. */
    // "outDir": "./",                        /* Redirect output structure to the directory. */
    // "rootDir": "./",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // "composite": true,                     /* Enable project compilation */
    // "tsBuildInfoFile": "./",               /* Specify file to store incremental compilation information */
    // "removeComments": true,                /* Do not emit comments to output. */
    // "noEmit": true,                        /* Do not emit outputs. */
    // "importHelpers": true,                 /* Import emit helpers from 'tslib'. */
    // "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */
    /* Strict Type-Checking Options */
    "strict": true, /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,              /* Enable strict null checks. */
    // "strictFunctionTypes": true,           /* Enable strict checking of function types. */
    // "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */
    // "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */
    /* Additional Checks */
    // "noUnusedLocals": true,                /* Report errors on unused locals. */
    // "noUnusedParameters": true,            /* Report errors on unused parameters. */
    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */
    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */
    /* Module Resolution Options */
    // "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */
    // "paths": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    // "typeRoots": [],                       /* List of folders to include type definitions from. */
    // "types": [],                           /* Type declaration files to be included in compilation. */
    // "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    "esModuleInterop": true, /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    // "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */
    // "allowUmdGlobalAccess": true,          /* Allow accessing UMD globals from modules. */
    /* Source Map Options */
    // "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */
    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */
    /* Experimental Options */
    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */
    // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */
    /* Advanced Options */
    "skipLibCheck": true, /* Skip type checking of declaration files. */
    "forceConsistentCasingInFileNames": true /* Disallow inconsistently-cased references to the same file. */
  }
}
```

There are a lot of options here we can set, for example `"strict": true` is very important to enable all strict type-checking options. For example in this snippet:

```ts
// app.ts
button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  console.log(result);
});
```

`button` is possibly `null`. **TypeScript** can't know whether that `button` actually exists, it does not check our HTML code; so therefore this could be `null` This is one `"strict"` mode feature. Consider these options:

```json
// tsconfig.json
    "strict": true, /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,              /* Enable strict null checks. */
    // "strictFunctionTypes": true,           /* Enable strict checking of function types. */
    // "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */
    // "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,
```

All those checks here are turned on if `"strict"` is set to `true`.

So to work around this (solve `null` state in `button` element), we have two options. We can add some code here where **we check if `button` is Truthy**:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button");

function add(num1: number, num2: number) {
  return num1 + num2;
}

if (button) {
  button.addEventListener("click", () => {
    const num1 = num1Element.value;
    const num2 = num2Element.value;
    const result = add(+num1, +num2);
    console.log(result);
  });
}
```

Now we know that if this code runs `button` can't be `null`. Because if it would be `null`, it would be Falsy and we wouldn't make it into this `if` check.

**Alternatively**, we know that there will be a button (button exists). We can add an `!` exclamation mark here near the `querySelector`:

```ts
// app.ts
const button = document.querySelector("button")!;
```

This means the statement in front of `button` (i.e. `document.querySelector("button")`), could be `null`, but we know that it isn't. So we tell to **TypeScript** that **please ignore that `null` case and take the other value**. In this case, it takes `HTMLButtonElement` as the only value (before it was `HTMLButtonElement | null`).

One other thing that wouldn't be allowed with `"strict"` mode, is that we omit the type of one parameter for example, now it complains that this parameter implicitly has the `any` type. There is an `any` which we cannot sign. If we add it explicitly, it would be worked:

```ts
// app.ts
function add(num1: any, num2: number) {
  return num1 + num2;
}
```

**Note**: We don't recommend you to add `any` type. It carries no extra type information; `any` kind of value is allowed here. Therefore, this is just a type you should know if you have no idea which kind of data you can expect. In the other words, **explicit `any` is allowed and implicit `any` isn't**.

To compile this code to **JavaScript** code, if we just write `tsc app.ts` command, the configuration file is ignored for the type of compilation. If we just write `tsc` command (run `tsc`), it takes all **TypeScript** files and the configuration file.

**Note**: The IDE (VS Code) always picks up to `tsconfig.json` file. So the IDE support is always provided; no matter how we compile it.

Now we have this **JavaScript** code:

```js
// app.js
"use strict";
var num1Element = document.getElementById("num1");
var num2Element = document.getElementById("num2");
var button = document.querySelector("button");
function add(num1, num2) {
    return num1 + num2;
}
button.addEventListener("click", function () {
    var num1 = num1Element.value;
    var num2 = num2Element.value;
    var result = add(+num1, +num2);
    console.log(result);
});
```

## Working with Union Types

If we want to work with more types in our function's parameters, we can set `any` type in both parameters. Bur as a downside, we don't want to accept the `boolean` type, for example:

```ts
// app.ts
function add(num1: any, num2: any) {
  return num1 + num2;
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  console.log(result);
  console.log(add(true, false));
});
```

We want to accept strings and numbers. That's where we can use a feature called the **Union Type**. We can define multiple types, like number and string, separated with `|` single pipe symbol; this is a Union Type. For example:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button")!;

function add(num1: number | string, num2: number | string) {
  return num1 + num2;
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  console.log(result);
  console.log(add("Hamid", "Hamed"));
});
```

There is an error in `return num1 + num2;` line, because the `+` operator doesn't work with both number and string. **TypeScript** at the moment at least doesn't understand this. We can solve this issue with `if` check:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button")!;

function add(num1: number | string, num2: number | string) {
  if (typeof num1 === "number" && typeof num2 === "number") {
    return num1 + num2;
  } else if (typeof num1 === "string" && typeof num2 === "string") {
    return `${num1} ${num2}`;
  }
  return +num1 + +num2;
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  const stringResult = add(num1, num2);
  console.log(result);
  console.log(stringResult);
});
```

Now our code works great.

## Using Object & Array Types

If we want to work with our function which is have object, we can set `object` type for that object, for example:

```ts
// app.ts
function printResult(obj: { val: number; timestamp: Date }) {
  console.log(obj.val);
}
```

**Important**: We don't create a new object in the parameter section, this is just a object strucure that we can define type for every property of that object. In this example, we expect that the `val` property should be a number and the `timestamp` property should be a date format.

Now we can add it to our event listener:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button")!;

function add(num1: number | string, num2: number | string) {
  if (typeof num1 === "number" && typeof num2 === "number") {
    return num1 + num2;
  } else if (typeof num1 === "string" && typeof num2 === "string") {
    return `${num1} ${num2}`;
  }
  return +num1 + +num2;
}

function printResult(obj: { val: number; timestamp: Date }) {
  console.log(obj.val);
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  const stringResult = add(num1, num2);
  printResult({ val: result, timestamp: new Date() });
});
```

We would get an error there, we cast the `val` property with as `number` type:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button")!;

function add(num1: number | string, num2: number | string) {
  if (typeof num1 === "number" && typeof num2 === "number") {
    return num1 + num2;
  } else if (typeof num1 === "string" && typeof num2 === "string") {
    return `${num1} ${num2}`;
  }
  return +num1 + +num2;
}

function printResult(obj: { val: number; timestamp: Date }) {
  console.log(obj.val);
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  const stringResult = add(num1, num2);
  printResult({ val: result as number, timestamp: new Date() }); // <-- this line
});
```

Sometimes we want to work with arrays, for example:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button")!;

const numResults = [];
const textResults = [];

function add(num1: number | string, num2: number | string) {
  if (typeof num1 === "number" && typeof num2 === "number") {
    return num1 + num2;
  } else if (typeof num1 === "string" && typeof num2 === "string") {
    return `${num1} ${num2}`;
  }
  return +num1 + +num2;
}

function printResult(obj: { val: number; timestamp: Date }) {
  console.log(obj.val);
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  numResults.push(result);
  const stringResult = add(num1, num2);
  textResults.push(stringResult);
  printResult({ val: result as number, timestamp: new Date() });
});
```

If we write `console.log(numResults, textResults);`, we would get an error. Because the type of both arrays is `any[]`. As you know, **explicit `any` is allowed and implicit `any` isn't**. So we can define `any[]` type for those arrays. But we don't recommend this way. Instead we want to store data as number in `numResults` array and string in `textResults` array:

```ts
// app.ts
const numResults: number[] = [];
const textResults: string[] = [];
```

This means that the type of data stored in `numResults` is an array full of numbers. As our parameters in `add()` function are Union Type, we must cast them to number and string:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button")!;

const numResults: number[] = [];
const textResults: string[] = [];

function add(num1: number | string, num2: number | string) {
  if (typeof num1 === "number" && typeof num2 === "number") {
    return num1 + num2;
  } else if (typeof num1 === "string" && typeof num2 === "string") {
    return `${num1} ${num2}`;
  }
  return +num1 + +num2;
}

function printResult(obj: { val: number; timestamp: Date }) {
  console.log(obj.val);
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  numResults.push(result as number); // <-- this line
  const stringResult = add(num1, num2);
  textResults.push(stringResult as string); // <-- and this line
  printResult({ val: result as number, timestamp: new Date() });
  console.log(numResults, textResults);
});
```

## Working with Type Aliases & Interfaces

We use some repetition here. For example, in `function add(num1: number | string, num2: number | string) { ...` line, we use `number | string` twice. We can optimize this or improve this line with a **type alias**.

We can define aliases in **TypeScript** with `type` keyword and then name of that type (whatever we want); hen we set type or types here, for example:

```ts
// app.ts
type NumOrString = number | string;

function add(num1: NumOrString, num2: NumOrString) {
  if (typeof num1 === "number" && typeof num2 === "number") {
    return num1 + num2;
  } else if (typeof num1 === "string" && typeof num2 === "string") {
    return `${num1} ${num2}`;
  }
  return +num1 + +num2;
}
```

**Note**: We can store any type in such a **type alias**. For example we can store object type in aliases:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button")!;

const numResults: number[] = [];
const textResults: string[] = [];

type NumOrString = number | string;
type Result = { val: number; timestamp: Date };

function add(num1: NumOrString, num2: NumOrString) {
  if (typeof num1 === "number" && typeof num2 === "number") {
    return num1 + num2;
  } else if (typeof num1 === "string" && typeof num2 === "string") {
    return `${num1} ${num2}`;
  }
  return +num1 + +num2;
}

function printResult(obj: Result) {
  console.log(obj.val);
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  numResults.push(result as number);
  const stringResult = add(num1, num2);
  textResults.push(stringResult as string);
  printResult({ val: result as number, timestamp: new Date() });
  console.log(numResults, textResults);
});
```

So type aliases can be very useful. An alternative, at least when we're working with object types, are **interfaces**.

Interfaces also allow us to define the structure of an object. For example:

```ts
// app.ts
const num1Element = document.getElementById("num1") as HTMLInputElement;
const num2Element = document.getElementById("num2") as HTMLInputElement;
const button = document.querySelector("button")!;

const numResults: number[] = [];
const textResults: string[] = [];

type NumOrString = number | string;
// type Result = { val: number; timestamp: Date };
interface ResultObj { // <-- this line
  val: number;
  timestamp: Date;
}

function add(num1: NumOrString, num2: NumOrString) {
  if (typeof num1 === "number" && typeof num2 === "number") {
    return num1 + num2;
  } else if (typeof num1 === "string" && typeof num2 === "string") {
    return `${num1} ${num2}`;
  }
  return +num1 + +num2;
}

function printResult(obj: ResultObj) { // <-- this line
  console.log(obj.val);
}

button.addEventListener("click", () => {
  const num1 = num1Element.value;
  const num2 = num2Element.value;
  const result = add(+num1, +num2);
  numResults.push(result as number);
  const stringResult = add(num1, num2);
  textResults.push(stringResult as string);
  printResult({ val: result as number, timestamp: new Date() });
  console.log(numResults, textResults);
});
```

**Q**: What's the difference?

**Answer**: Interfaces can also be used to force classes to implement certain methods or functionalities.

**Important**: If we would add our own class or constructor function, we could use the class name as a type; just as we're using `Date` interface here. We can use `Date` with `new Date()` to instantiate it and get the current date time stamp, **but we can also use it just as a type**. That's true for any constructor function and class (no matter if it's a built-in one or oue own one).

## Generic Types

Consider this simple function:

```ts
function logAndEcho(val: any) {
  console.log(val);
  return val;
}

logAndEcho("Hamid Alavi");
```

This could be a generic function. Now here, we accept `any` type of data, but then we don't get any extra **TypeScript** support. If we want to do `logAndEcho("Hamid Alavi").split(" ");`, we can't do that. Because **TypeScript** doesn't know what `logAndEcho()` returns (type), it returns anything, because we set the value type to `any` here.

So, that's where gereric types can help us. We can create a generic function in this case. We do that by adding `< >` angled brackets after the function name (before the parameter list) and then typically we use `<T>` as a placeholder for the type. Then we say `val` is also of type `<T>`:

```ts
function logAndEcho<T>(val: T) {
  console.log(val);
  return val;
}

logAndEcho("Hamid Alavi").split(" ");
```

**Note**: You can use any identifier you want. But `<T>` is what you'd see most often. You can also use core types here like `number`, `string` and so on.

For arrays, we can use longer form which is generic type, for example:

```ts
// app.ts
const numResults: number[] = []; // normal

const numResult: Array<number> = []; // generic type
```

## Node and TypeScript

Consider this example:

```js
// app.js
const express = require("express");

const app = express();

app.listen(3000);
```

This code is invalid for **TypeScript**, if we would want to run it in the browser, this does not exist. We can solve this problem with `npm install --save-dev @types/node` command. With this package, we can use **Node.js** specific syntax in our **TypeScript** files; because this dependency will provide **TypeScript** with the translation of this to **JavaScript**.

So the translation file exist in `node_modules -> @types/node -> index.d.ts` path.

Now this code would works fine. If you use Vs Code here, there is no auto completion for `app` object. For example, if we use `app.listen({port: 3000})` instead of `app.listen(3000)`, this compiles just fine. Because **TypeScript** does not understand how this `listen` method looks like, which arguments it wants and how it works.

We can avoid this unwanted successful compiles at this time. We can avoid these problem with `npm install --save-dev @types/express` command. We can also use translation for other libraries just with `npm install --save-dev @types/<packageName>`. We used `express` here.

If we use this package, we still don't get any error and auto completion. To solve this problem, we need to chnage the import syntax here:

```ts
// app.ts
import express = require("express");

const app = express();

app.listen(3000);
```

or we can use ES module syntax which is best thing in modern web pages:

```ts
// app.ts
import express from "express";

const app = express();

app.listen(3000);
```

The good news is, that the **TypeScript** also knows the modern import syntax, but we need to configure this:

```json
// tsconfig.json
{
  "target": "es6",
  "module": "commonjs",
  "moduleResolution": "node"
}
```

With that, auto completion works and **TypeScript** also knows the methods and objects in `express` framework.

But after comilation, the syntax will return the `require()`:

```js
// app.js
"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express")); // <-- this line
const app = express_1.default();
app.listen(3000);
```

**Note**: We didn't change the `package.json` file to enable this import syntax. We'll also still be able to omit file extensions.

## Simple REST API with TypeScript

```json
// package.json
{
  "name": "nodejs-step-by-step",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Hamid Alavi",
  "license": "ISC",
  "dependencies": {
    "body-parser": "^1.19.0",
    "express": "^4.17.1"
  },
  "devDependencies": {
    "@types/express": "^4.17.11",
    "@types/node": "^14.14.22"
  }
}
```

```ts
// app.ts
import express from "express";
import bodyParser from "body-parser";
import todosRoutes from "./routes/todos";

const app = express();

app.use(bodyParser.json());
app.use(todosRoutes);

app.listen(3000);
```

```ts
// todos.ts - in `routes` folder
import { Router } from "express";
import { Todo } from "../models/todo";

let todos: Todo[] = [];

const router = Router();

router.get("/", (req, res, next) => {
  res.status(200).json({ todo: todos });
});

router.post("/todo", (req, res, next) => {
  const newTodo: Todo = {
    id: new Date().toISOString(),
    text: req.body.text
  };

  todos.push(newTodo);

  return res
    .status(201)
    .json({ message: "Added todo", todo: newTodo, todos: todos });
});

router.put("/todo/:todoId", (req, res, next) => {
  const tid = req.params.todoId;
  const todoIndex = todos.findIndex(todoItem => todoItem.id === tid);
  if (todoIndex >= 0) {
    todos[todoIndex] = { id: todos[todoIndex].id, text: req.body.text };
    return res.status(200).json({ message: "Updated todo", todos: todos });
  }
  res.status(404).json({ message: "Could not find todo for this id!" });
});

router.delete("/todo/:todoId", (req, res, next) => {
  todos = todos.filter(todoItem => todoItem.id !== req.params.todoId);
  res.status(200).json({ message: "Deleted todo", todos: todos });
});

export default router;
```

```js
// todo.ts - in `models` folder
export interface Todo {
  id: string;
  text: string;
}
```

If we use `tsc` it compiles all `.ts` files to `.js`. We can test it with `node app.js` and postman.

**Note**: We can only execute **JavaScript** code with Node. Node isn't capable of running **TypeScript** code. We can convert **TypeScript** code to **JavaScript** and then execute or run that code.

We can get response from server with `GET` method and `http://localhost:3000` URL and pressing `Send` button in postman. It would be an empty array the first time.

We can also send a POST request to add todo with `POST` method and `http://localhost:3000/todo` URL:

```json
// POST request
{
    "text": "Hamid"
}
```

and pressing `Send` button. Then we get response from the server which contains:

```json
// POST response
{
    "message": "Added todo",
    "todo": {
        "id": "2021-01-30T22:17:50.955Z",
        "text": "Hamid"
    },
    "todos": [
        {
            "id": "2021-01-30T22:17:50.955Z",
            "text": "Hamid"
        }
    ]
}
```

Now if we want to get data again, it would contains:

```json
// GET response
{
    "todo": [
        {
            "id": "2021-01-30T22:17:50.955Z",
            "text": "Hamid"
        }
    ]
}
```

We can update our data with `PUT` method and `http://localhost:3000/todo/2021-01-30T22:17:50.955Z` URL:

```json
{
    "text": "Updated!"
}
```

Then we get response from the server which contains:

```json
// PUT response
{
    "message": "Updated todo",
    "todos": [
        {
            "id": "2021-01-30T22:17:50.955Z",
            "text": "Updated!"
        }
    ]
}
```

The last step is deleting todo from the list with `DELETE` method and just inserting `http://localhost:3000/todo/2021-01-30T22:17:50.955Z` URL to delete a specific todo:

```json
// DELETE response
{
    "message": "Deleted todo",
    "todos": []
}
```

Now as you can see, our todo list is empty.

## Using Better Code

There is a little bit problem in our code. As you know, **TypeScript** don't know our express and Node code; so if we change the `req.body` to `req.bodyyy`, **TypeScript** can't anticipate (predict) the problem and there is maybe a type here. To avoid this typo, we can't forct it to be correct type, for example:

```ts
// todos.ts - in `routes` folder
import { Router } from "express";
import { Todo } from "../models/todo";

type RequestBody = { text: string };
type RequestParams = { todoId: string };

let todos: Todo[] = [];

const router = Router();

router.get("/", (req, res, next) => {
  res.status(200).json({ todo: todos });
});

router.post("/todo", (req, res, next) => {
  const body = req.body as RequestBody;
  const newTodo: Todo = {
    id: new Date().toISOString(),
    text: body.text
  };

  todos.push(newTodo);

  return res
    .status(201)
    .json({ message: "Added todo", todo: newTodo, todos: todos });
});

router.put("/todo/:todoId", (req, res, next) => {
  const params = req.params as RequestParams;
  const tid = params.todoId;
  const body = req.body as RequestBody;
  const todoIndex = todos.findIndex(todoItem => todoItem.id === tid);
  if (todoIndex >= 0) {
    todos[todoIndex] = { id: todos[todoIndex].id, text: body.text };
    return res.status(200).json({ message: "Updated todo", todos: todos });
  }
  res.status(404).json({ message: "Could not find todo for this id!" });
});

router.delete("/todo/:todoId", (req, res, next) => {
  const params = req.params as RequestParams;
  todos = todos.filter(todoItem => todoItem.id !== params.todoId);
  res.status(200).json({ message: "Deleted todo", todos: todos });
});

export default router;
```

We used `RequestBody` and `RequestParams` types for `req.body` and `req.params` request. With this way, we can avoid mistake alot.

We can test our app again with the help of postman. It forces us to write a better code.

## One Important Note

We're done with our project. But we could add `controllers` folder to split our code and more readable. But this is a basic REST API project and we didn't use `controllers` here.

But if we compile **TypeScript** code to **JavaScript**, we don't want to **JavaScript** files add near our **TypeScript** files. We want to move all of the files and folder which contain **JavaScript** code, to the specific directory. We can do this with `"outDir"` property in the `tsconfig.json` file. It redirect output structure to the directory, for example we want to all **JavaScript** code move to the `dist` folder; so we can write `"outDir": "./dist"` here in the `tsconfig.json` file.

Now if we write `tsc` in terminal, new folder will be added which is called `dist` that contains all our **JavaScript** code and their folder (folder with sub items).

We can also change the root directory (which are our **TypeScript** code there) with `"rootDir"` property in the `tsconfig.json` file. For example we want to all **TypeScript** code move to the `src` folder; so we can write `"rootDir": "./src"` here in the `tsconfig.json` file.

## Optional Properties - Bonus

As you know, in **TypeScript**, in all objects we can add context type for them. If we want to add interface here, it forces us to write that type:

```ts
// app.ts
interface Optional {
  id: number;
  text: string;
}

const myTest: Optional = { id: 23, text: "Hamid is good" };
```

For example, if we just write `{ text: "Hamid is good" }`, it would be failed because of `id` is missing. We can add an optional property here with adding `?` question mark in front of the property name:

```js
// app.ts
interface Optional {
  id?: string;
  text: string;
}

const myTest: Optional = { text: "Hamid is good" };
```

With this option, we can ignore some properties in our objects.
